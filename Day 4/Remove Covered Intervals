# Remove Covered Intervals

## Problem Statement:
Given a list of *intervals*, remove all intervals that are covered by another interval in the list.

Interval *[a,b)* is covered by interval *[c,d)* if and only if *c <= a* and *b <= d*.

After doing so, return the number of remaining intervals.

```
Input: intervals = [[1,4],[3,6],[2,8]]
Output: 2
Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.
```
```
Input: intervals = [[1,4],[2,3]]
Output: 1
```
```
Input: intervals = [[0,10],[5,12]]
Output: 2
```
```
Input: intervals = [[3,10],[4,10],[5,11]]
Output: 2
```
```
Input: intervals = [[1,2],[1,4],[3,4]]
Output: 1
```

### Constraints:
* 1 <= intervals.length <= 1000
* intervals[i].length == 2
* 0 <= intervals[i][0] < intervals[i][1] <= 10^5
* All the intervals are unique.

## Solution:

```
class Solution {
    public int removeCoveredIntervals(int[][] intervals) {
        int total=intervals.length;
        HashMap<Integer,Boolean> map=new HashMap<>();
        int n=total;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i!=j&&intervals[i][0]<=intervals[j][0]&&intervals[i][1]>=intervals[j][1]&&!map.containsKey(j)){
                    map.put(j,true);
                    total--;
                }
            }
        }
        return total;
    }
}
```
